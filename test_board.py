# -*- coding: utf-8 -*-
"""Unit Tests for PDU Control Script (Final Fixes v2)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yKdA5DTy8Q0IIZlGDTh4Gz1FB2yVi2M-
"""

import unittest
import sys
import os
import io
import subprocess
import json
import argparse
import logging
from unittest.mock import patch, MagicMock, mock_open, call, ANY
from collections import namedtuple, defaultdict

# Import the script we want to test
import board

# --- Mock Configuration Data ---
# Config data matching the structure used by the keyring-enabled script
MOCK_VALID_CONFIG_KEYRING = {
  "pdus": {
    "pdu1": { "ip": "10.0.0.1" },
    "pdu2": { "ip": "10.0.0.2" }
  },
  "sockets": {
    "sockA": { "pdu_id": "pdu1", "outlet": 1, "serial": "/dev/ttyS0", "baudrate": 115200 },
    "sockB": { "pdu_id": "pdu1", "outlet": 2, "serial": "/dev/ttyS1", "baudrate": 9600 },
    "sockC": { "pdu_id": "pdu2", "outlet": 5, "serial": "/dev/ttyS8", "baudrate": 115200 },
    "sockD": { "pdu_id": "pdu2", "outlet": 8, "serial": "/dev/ttyS9", "baudrate": 115200 }
  }
}
# Minimal valid config
MOCK_MINIMAL_CONFIG = {
    "pdus": {"minipdu": {"ip": "192.168.10.10"}},
    "sockets": {"minisock": {"pdu_id": "minipdu", "outlet": 1, "serial": "/dev/ttyUSB0", "baudrate": 9600}}
}
# Empty config
MOCK_EMPTY_CONFIG = {}
MOCK_CONFIG_NO_SOCKETS = {"pdus": {"pdu1": {"ip": "1.1.1.1"}}, "sockets": {}}
MOCK_CONFIG_NO_PDUS = {"pdus": {}, "sockets": {"s1": {"pdu_id": "pdu1", "outlet": 1, "serial":"/dev/ttyS0", "baudrate": 9600}}}

# Define invalid configs for validation tests
MOCK_INVALID_CONFIG_BAD_REF = {
  "pdus": { "pdu1": { "ip": "1.1.1.1"}},
  "sockets": { "s1": { "pdu_id": "pdu_UNKNOWN", "outlet": 1, "serial": "/dev/ttyS0", "baudrate": 115200 }}
}
MOCK_INVALID_CONFIG_OUTLET_CONFLICT = {
  "pdus": { "pdu1": { "ip": "1.1.1.1"}},
  "sockets": {
    "s1": { "pdu_id": "pdu1", "outlet": 1, "serial": "/dev/ttyS0", "baudrate": 115200 },
    "s2": { "pdu_id": "pdu1", "outlet": 1, "serial": "/dev/ttyS1", "baudrate": 115200 }
}}
MOCK_INVALID_CONFIG_MISSING_KEY = { # Missing outlet in socket
  "pdus": { "pdu1": { "ip": "1.1.1.1"}},
  "sockets": { "s1": { "pdu_id": "pdu1", "serial": "/dev/ttyS0", "baudrate": 115200 }}
}
MOCK_INVALID_CONFIG_SERIAL_CONFLICT = {
  "pdus": { "pdu1": { "ip": "1.1.1.1"}},
  "sockets": {
    "s1": { "pdu_id": "pdu1", "outlet": 1, "serial": "/dev/ttyS0", "baudrate": 115200 },
    "s2": { "pdu_id": "pdu1", "outlet": 2, "serial": "/dev/ttyS0", "baudrate": 115200 }
}}
MOCK_INVALID_TYPE_OUTLET = {
  "pdus": { "pdu1": { "ip": "1.1.1.1"}},
  "sockets": { "s1": { "pdu_id": "pdu1", "outlet": "1", "serial": "/dev/ttyS0", "baudrate": 115200 }}
}
MOCK_INVALID_TYPE_BAUD = {
  "pdus": { "pdu1": { "ip": "1.1.1.1"}},
  "sockets": { "s1": { "pdu_id": "pdu1", "outlet": 1, "serial": "/dev/ttyS0", "baudrate": "115200" }}
}
MOCK_INVALID_FORMAT_SERIAL = {
  "pdus": { "pdu1": { "ip": "1.1.1.1"}},
  "sockets": { "s1": { "pdu_id": "pdu1", "outlet": 1, "serial": "ttyS0", "baudrate": 115200 }}
}
MOCK_INVALID_EMPTY_IP = {
  "pdus": { "pdu1": { "ip": ""}},
  "sockets": { "s1": { "pdu_id": "pdu1", "outlet": 1, "serial": "/dev/ttyS0", "baudrate": 115200 }}
}


# --- Mock Credential Object ---
Credential = namedtuple('Credential', ['username', 'password'])
DEFAULT_MOCK_USERNAME = 'mock_user'
DEFAULT_MOCK_PASSWORD = 'mock_pass'
DEFAULT_MOCK_CREDENTIAL = Credential(username=DEFAULT_MOCK_USERNAME, password=DEFAULT_MOCK_PASSWORD)
EMPTY_MOCK_CREDENTIAL = Credential(username="", password="")


# --- Test Setup ---

class ExitCalled(BaseException):
    """Custom exception to catch sys.exit calls."""
    def __init__(self, code):
        self.code = code

def raise_exit_called(code=None):
    """Helper for mocking sys.exit."""
    exit_code_int = 0
    if isinstance(code, int): exit_code_int = code
    elif code is not None:
        try: exit_code_int = int(code)
        except (ValueError, TypeError): pass
    raise ExitCalled(exit_code_int)

class TestBoardScriptRefactored(unittest.TestCase):
    """Test suite for the refactored board.py script."""

    original_stderr = sys.stderr
    original_stdout = sys.stdout
    board_logger = None # Store logger reference

    @classmethod
    def setUpClass(cls):
        """Set up logging capture for all tests."""
        cls.log_stream = io.StringIO()
        cls.log_handler = logging.StreamHandler(cls.log_stream)
        cls.log_handler.setFormatter(
            logging.Formatter('%(levelname)s:%(name)s:%(message)s')
        )
        # Capture logs from the logger named 'board' in board.py
        cls.board_logger = logging.getLogger('board')
        cls.board_logger.setLevel(logging.DEBUG) # Ensure DEBUG messages are captured
        if cls.board_logger.hasHandlers():
            cls.board_logger.handlers.clear()
        cls.board_logger.addHandler(cls.log_handler)
        cls.board_logger.propagate = False


    @classmethod
    def tearDownClass(cls):
        """Remove logging handler."""
        if cls.board_logger:
            cls.board_logger.removeHandler(cls.log_handler)
            cls.board_logger.propagate = True


    def setUp(self):
        """Set up mocks for dependencies before each test."""
        self.log_stream.seek(0)
        self.log_stream.truncate(0)
        self.mock_stderr = io.StringIO()
        self.mock_stdout = io.StringIO()
        sys.stderr = self.mock_stderr
        sys.stdout = self.mock_stdout

        self.addCleanup(patch.stopall) # Stop all patches started with patch().start()

        self.mock_exit = patch('sys.exit', side_effect=raise_exit_called).start()
        self.mock_parse_args = patch('argparse.ArgumentParser.parse_args').start()
        self.mock_exists = patch('os.path.exists', return_value=True).start()
        self.mock_json_load = patch('json.load', return_value=MOCK_VALID_CONFIG_KEYRING).start()
        self.mock_keyring_get_credential = patch('keyring.get_credential', return_value=DEFAULT_MOCK_CREDENTIAL).start()
        # Patch IPU where it's imported in board.py, with autospec
        self.MockIPUClass = patch('board.IPU', autospec=True).start()
        self.mock_pdu_instance = MagicMock()
        # Ensure the mocked class returns our instance mock when called
        self.MockIPUClass.return_value = self.mock_pdu_instance
        self.mock_check_output = patch('subprocess.check_output', return_value=b'/usr/bin/picocom\n').start()
        self.mock_popen = patch('subprocess.Popen').start()
        self.mock_popen_instance = MagicMock(pid=12345)
        self.mock_popen.return_value = self.mock_popen_instance

    def tearDown(self):
        """Restore stdout/stderr."""
        sys.stderr = self.original_stderr
        sys.stdout = self.original_stdout

    def get_log_output(self):
        """Helper to get captured log output."""
        return self.log_stream.getvalue()

    def assert_log_contains(self, expected_substring):
        """Asserts that the captured log contains the expected substring."""
        log_content = self.get_log_output()
        self.assertIn(expected_substring, log_content,
                      msg=f"Expected substring '{expected_substring}' not found in log:\n'''{log_content}'''")


    def assert_log_not_contains(self, unexpected_substring):
        """Asserts that the captured log does not contain the unexpected substring."""
        log_content = self.get_log_output()
        self.assertNotIn(unexpected_substring, log_content,
                         msg=f"Unexpected substring '{unexpected_substring}' found in log:\n'''{log_content}'''")


    def simulate_args(self, args_list):
        """Configures the parse_args mock to return simulated args."""
        simulated_args = argparse.Namespace(
            config=board.DEFAULT_CONFIG_FILENAME,
            socket_names=[],
            action=None,
            verbose=False
        )
        temp_args_list = list(args_list)
        # Handle -c/--config
        config_path = board.DEFAULT_CONFIG_FILENAME
        indices_to_remove = []
        for i, arg in enumerate(temp_args_list):
            if arg == '-c' or arg == '--config':
                if i + 1 < len(temp_args_list):
                    config_path = temp_args_list[i + 1]
                    indices_to_remove.extend([i, i + 1])
                break # Assume only one config arg
        simulated_args.config = config_path
        # Remove processed args by index (reversed to avoid index shifting)
        for i in sorted(indices_to_remove, reverse=True):
            del temp_args_list[i]

        # Handle -v/--verbose
        if '-v' in temp_args_list or '--verbose' in temp_args_list:
             simulated_args.verbose = True
             temp_args_list = [a for a in temp_args_list if a not in ('-v', '--verbose')]

        # Remaining args are action and socket_names
        if len(temp_args_list) >= 1:
             simulated_args.action = temp_args_list[-1]
             simulated_args.socket_names = temp_args_list[:-1]

        self.mock_parse_args.return_value = simulated_args
        return simulated_args

    def configure_mocks(self, config_exists=True, config_data=MOCK_VALID_CONFIG_KEYRING, json_error=None,
                        keyring_credential=DEFAULT_MOCK_CREDENTIAL, keyring_error=None,
                        check_output_effect=None, popen_error=None, ipu_effect=None,
                        enable_outlets_effect=None, disable_outlets_effect=None):
        """Helper to configure mocks for a test run."""
        # Reset mocks that might have state
        self.mock_exists.reset_mock()
        self.mock_json_load.reset_mock()
        self.mock_keyring_get_credential.reset_mock()
        self.mock_check_output.reset_mock()
        self.mock_popen.reset_mock()
        self.MockIPUClass.reset_mock()
        # Reset the side_effect/return_value explicitly for IPU mock
        self.MockIPUClass.side_effect = None
        self.MockIPUClass.return_value = self.mock_pdu_instance
        self.mock_pdu_instance.reset_mock()
        self.mock_pdu_instance.enable_outlets.reset_mock(side_effect=None)
        self.mock_pdu_instance.disable_outlets.reset_mock(side_effect=None)

        # Configure file/JSON mocks
        self.mock_exists.return_value = config_exists
        if json_error:
            self.mock_json_load.side_effect = json_error
        else:
            self.mock_json_load.side_effect = None
            self.mock_json_load.return_value = config_data

        # Configure keyring mock
        if keyring_error:
            self.mock_keyring_get_credential.side_effect = keyring_error
        else:
            self.mock_keyring_get_credential.side_effect = None
            self.mock_keyring_get_credential.return_value = keyring_credential

        # Configure check_output mock (for picocom check)
        if check_output_effect:
             self.mock_check_output.side_effect = check_output_effect
        else:
             self.mock_check_output.side_effect = None
             self.mock_check_output.return_value = b'/usr/bin/picocom\n'

        # Configure Popen mock (for picocom execution)
        if popen_error:
            self.mock_popen.side_effect = popen_error
        else:
            self.mock_popen.side_effect = None
            self.mock_popen.return_value = self.mock_popen_instance

        # Configure IPU mock (for PDU errors)
        # This applies to the MOCK class object itself (for __init__)
        if ipu_effect:
            # If ipu_effect is an Exception, set it as side_effect for the class
            if isinstance(ipu_effect, Exception) or (isinstance(ipu_effect, type) and issubclass(ipu_effect, BaseException)): # Check BaseException
                 self.MockIPUClass.side_effect = ipu_effect
            # If it's a list (for sequential calls), set it as side_effect
            elif isinstance(ipu_effect, list):
                 self.MockIPUClass.side_effect = ipu_effect
            # Otherwise, assume it's the instance to return (though default is already set)
            else:
                 self.MockIPUClass.return_value = ipu_effect
        # Ensure default return value if no effect is specified (handled by reset)

        # Configure side effects for PDU actions on the MOCK INSTANCE
        if enable_outlets_effect:
            self.mock_pdu_instance.enable_outlets.side_effect = enable_outlets_effect
        if disable_outlets_effect:
            self.mock_pdu_instance.disable_outlets.side_effect = disable_outlets_effect


    def run_script(self, args):
        """
        Helper method to run the board.main() function with specific args.
        Returns the exit code caught by the sys.exit mock.
        """
        # Reset streams and call counts for mocks used across all tests
        self.mock_stderr.seek(0); self.mock_stderr.truncate(0)
        self.mock_stdout.seek(0); self.mock_stdout.truncate(0)
        self.log_stream.seek(0); self.log_stream.truncate(0)
        # Don't reset mocks here, configure_mocks called by each test

        # Simulate args for this run MUST be called before configure_mocks in test method
        self.simulate_args(args)

        exit_code_caught = None
        try:
            board.main() # Call the main function directly
        except ExitCalled as e:
            exit_code_caught = e.code # Capture code from our exception
        except Exception as e:
            # Log unexpected exceptions for debugging
            print(f"\n--- Unexpected Exception during run_script({args}) ---", file=self.original_stderr)
            import traceback
            traceback.print_exc(file=self.original_stderr)
            print(f"Captured Stderr:\n{self.mock_stderr.getvalue()}", file=self.original_stderr)
            print(f"Captured Log:\n{self.get_log_output()}", file=self.original_stderr)
            raise e # Re-raise other errors

        # If ExitCalled was not caught (script finished without sys.exit)
        if exit_code_caught is None:
             print(f"\n--- Script finished without calling sys.exit for args: {args} ---", file=self.original_stderr)
             print(f"Captured Stderr:\n{self.mock_stderr.getvalue()}", file=self.original_stderr)
             print(f"Captured Log:\n{self.get_log_output()}", file=self.original_stderr)
             return -99 # Return an indicator of abnormal termination
        return exit_code_caught


    # --- Test Cases ---

    def test_main_no_args_fails(self):
        """Test main() exits if parse_args fails (simulated)."""
        self.mock_parse_args.side_effect = ExitCalled(2)
        exit_code = self.run_script([])
        self.assertEqual(exit_code, 2)

    def test_main_invalid_action_fails(self):
        """Test main() exits if parse_args fails on invalid action (simulated)."""
        self.mock_parse_args.side_effect = ExitCalled(2)
        exit_code = self.run_script(['sockA', 'invalid'])
        self.assertEqual(exit_code, 2)

    def test_config_file_not_found(self):
        """Test main() exits if config file not found."""
        self.simulate_args(['sockA', 'on'])
        self.configure_mocks(config_exists=False)
        exit_code = self.run_script(['sockA', 'on'])
        self.assertEqual(exit_code, 3)
        self.assert_log_contains("CRITICAL:board:Configuration file 'pdu_config.json' not found.")

    def test_config_invalid_json(self):
        """Test main() exits if config JSON is invalid."""
        self.simulate_args(['sockA', 'on'])
        self.configure_mocks(json_error=json.JSONDecodeError("Expecting value", "doc", 0))
        exit_code = self.run_script(['sockA', 'on'])
        self.assertEqual(exit_code, 3)
        self.assert_log_contains("CRITICAL:board:Error decoding JSON from 'pdu_config.json'")

    # --- Boundary Config Tests ---
    def test_config_empty(self):
        """Test validation fails for empty config, exits with unknown socket."""
        self.simulate_args(['sockA', 'on'])
        self.configure_mocks(config_data=MOCK_EMPTY_CONFIG)
        exit_code = self.run_script(['sockA', 'on'])
        self.assertEqual(exit_code, 1)
        self.assert_log_contains("CRITICAL:board:Unknown socket name(s): sockA.")
        self.assert_log_not_contains("CRITICAL:board:Configuration file 'pdu_config.json' has validation errors:")

    def test_config_no_sockets(self):
        """Test validation passes for config with no sockets, then fails on lookup."""
        self.simulate_args(['sockA', 'on'])
        self.configure_mocks(config_data=MOCK_CONFIG_NO_SOCKETS)
        exit_code = self.run_script(['sockA', 'on'])
        self.assertEqual(exit_code, 1)
        self.assert_log_contains("CRITICAL:board:Unknown socket name(s): sockA.")
        self.assert_log_contains("Available sockets:")

    def test_config_no_pdus(self):
        """Test validation fails if sockets reference non-existent PDUs."""
        self.simulate_args(['s1', 'on'])
        self.configure_mocks(config_data=MOCK_CONFIG_NO_PDUS)
        exit_code = self.run_script(['s1', 'on'])
        self.assertEqual(exit_code, 4)
        self.assert_log_contains("Socket 's1' references unknown pdu_id 'pdu1'")

    def test_config_minimal_success(self):
        """Test successful action with minimal valid config."""
        self.simulate_args(['minisock', 'on'])
        self.configure_mocks(config_data=MOCK_MINIMAL_CONFIG)
        self.mock_keyring_get_credential.configure_mock(
            side_effect=lambda service, user: DEFAULT_MOCK_CREDENTIAL if service == 'minipdu' else None
        )
        exit_code = self.run_script(['minisock', 'on'])
        self.assertEqual(exit_code, 0)
        self.mock_keyring_get_credential.assert_called_once_with('minipdu', None)
        self.MockIPUClass.assert_called_once_with('192.168.10.10', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
        self.mock_pdu_instance.enable_outlets.assert_called_once_with([0])
        self.assert_log_contains("INFO:board:Action 'on' completed successfully")

    # --- Granular Validation Tests ---
    def test_validate_non_int_outlet(self):
        """Test validation fails for non-integer outlet."""
        self.simulate_args(['s1', 'on'])
        self.configure_mocks(config_data=MOCK_INVALID_TYPE_OUTLET)
        exit_code = self.run_script(['s1', 'on'])
        self.assertEqual(exit_code, 4)
        self.assert_log_contains("Socket 's1' key 'outlet' must be a positive integer")

    def test_validate_non_int_baudrate(self):
        """Test validation fails for non-integer baudrate."""
        self.simulate_args(['s1', 'on'])
        self.configure_mocks(config_data=MOCK_INVALID_TYPE_BAUD)
        exit_code = self.run_script(['s1', 'on'])
        self.assertEqual(exit_code, 4)
        self.assert_log_contains("Socket 's1' key 'baudrate' must be a positive integer")

    def test_validate_bad_serial_format(self):
        """Test validation fails for serial not starting with '/'."""
        self.simulate_args(['s1', 'on'])
        self.configure_mocks(config_data=MOCK_INVALID_FORMAT_SERIAL)
        exit_code = self.run_script(['s1', 'on'])
        self.assertEqual(exit_code, 4)
        self.assert_log_contains("Socket 's1' key 'serial' must be a string starting with '/'")

    def test_validate_empty_ip(self):
        """Test validation fails for empty IP string."""
        self.simulate_args(['s1', 'on'])
        self.configure_mocks(config_data=MOCK_INVALID_EMPTY_IP)
        exit_code = self.run_script(['s1', 'on'])
        self.assertEqual(exit_code, 4)
        self.assert_log_contains("PDU 'pdu1' key 'ip' must be a non-empty string")


    # --- Previous Validation Tests ---
    def test_config_validation_failure_bad_ref(self):
        """Test config validation fails with bad pdu_id reference."""
        self.simulate_args(['s1', 'on'])
        self.configure_mocks(config_data=MOCK_INVALID_CONFIG_BAD_REF)
        exit_code = self.run_script(['s1', 'on'])
        self.assertEqual(exit_code, 4)
        self.assert_log_contains("Socket 's1' references unknown pdu_id 'pdu_UNKNOWN'")

    def test_config_validation_failure_outlet_conflict(self):
        """Test config validation fails with duplicate PDU/outlet assignment."""
        self.simulate_args(['s1', 'on'])
        self.configure_mocks(config_data=MOCK_INVALID_CONFIG_OUTLET_CONFLICT)
        exit_code = self.run_script(['s1', 'on'])
        self.assertEqual(exit_code, 4)
        self.assert_log_contains("Conflict: Socket 's2' and 's1' both use PDU 'pdu1' outlet 1")

    def test_config_validation_failure_serial_conflict(self):
        """Test config validation fails with duplicate serial port assignment."""
        self.simulate_args(['s1', 'on'])
        self.configure_mocks(config_data=MOCK_INVALID_CONFIG_SERIAL_CONFLICT)
        exit_code = self.run_script(['s1', 'on'])
        self.assertEqual(exit_code, 4)
        self.assert_log_contains("Conflict: Socket 's2' and 's1' both use serial port '/dev/ttyS0'")

    # --- Argument/Action Tests ---
    def test_unknown_socket_name(self):
        """Test main() exits if a specified socket name is not in config."""
        self.simulate_args(['unknown_socket', 'on'])
        self.configure_mocks()
        exit_code = self.run_script(['unknown_socket', 'on'])
        self.assertEqual(exit_code, 1)
        self.assert_log_contains("CRITICAL:board:Unknown socket name(s): unknown_socket.")

    def test_console_multiple_sockets_fails(self):
        """Test main() exits if 'console' action is used with multiple sockets."""
        self.simulate_args(['sockA', 'sockB', 'console'])
        self.configure_mocks()
        exit_code = self.run_script(['sockA', 'sockB', 'console'])
        self.assertEqual(exit_code, 1)
        self.assert_log_contains("CRITICAL:board:The 'console' action can only be performed on a single socket.")

    # --- Keyring Logic Tests ---
    def test_keyring_not_found(self):
        """Test main() exits if keyring credentials not found."""
        self.simulate_args(['sockA', 'on'])
        self.configure_mocks(keyring_credential=None)
        exit_code = self.run_script(['sockA', 'on'])
        self.assertEqual(exit_code, 1)
        self.assert_log_contains("ERROR:board:Credentials not found or incomplete for PDU 'pdu1' in keyring.")
        self.assert_log_contains("WARNING:board:Action could not be completed for some sockets due to PDU errors: sockA")

    def test_keyring_exception(self):
        """Test main() exits if keyring access fails."""
        self.simulate_args(['sockA', 'on'])
        self.configure_mocks(keyring_error=Exception("Keyring backend error"))
        exit_code = self.run_script(['sockA', 'on'])
        self.assertEqual(exit_code, 1)
        self.assert_log_contains("ERROR:board:Failed to retrieve credentials for PDU 'pdu1' from keyring")
        self.assert_log_contains("WARNING:board:Action could not be completed for some sockets due to PDU errors: sockA")

    # --- Console Action Tests ---
    def test_console_success(self):
        """Test successful console action."""
        self.simulate_args(['sockB', 'console'])
        self.configure_mocks()
        exit_code = self.run_script(['sockB', 'console'])
        self.assertEqual(exit_code, 0)
        self.mock_check_output.assert_called_once_with(["which", "picocom"], stderr=subprocess.DEVNULL)
        self.mock_popen.assert_called_once_with(["picocom", "-b", "9600", "/dev/ttyS1"], start_new_session=True)
        self.assert_log_contains("INFO:board:Successfully launched picocom")

    def test_console_picocom_not_found(self):
         """Test console action when picocom is not found."""
         self.simulate_args(['sockB', 'console'])
         self.configure_mocks(check_output_effect=subprocess.CalledProcessError(1, 'which'))
         exit_code = self.run_script(['sockB', 'console'])
         self.assertEqual(exit_code, 1)
         self.assert_log_contains("ERROR:board:'picocom' command not found or not executable.")

    # --- Power Action Tests ---
    def test_power_on_single_socket_success(self):
        """Test successful 'on' action for a single socket."""
        self.simulate_args(['sockC', 'on'])
        self.configure_mocks()
        exit_code = self.run_script(['sockC', 'on'])
        self.assertEqual(exit_code, 0)
        self.mock_keyring_get_credential.assert_called_once_with('pdu2', None)
        self.MockIPUClass.assert_called_once_with('10.0.0.2', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
        self.mock_pdu_instance.enable_outlets.assert_called_once_with([4])
        self.assert_log_contains("INFO:board:Action 'on' completed successfully")

    def test_power_off_multi_socket_same_pdu_success(self):
        """Test successful 'off' action for multiple sockets on the same PDU."""
        self.simulate_args(['sockA', 'sockB', 'off'])
        self.configure_mocks()
        exit_code = self.run_script(['sockA', 'sockB', 'off'])
        self.assertEqual(exit_code, 0)
        self.mock_keyring_get_credential.assert_called_once_with('pdu1', None)
        self.MockIPUClass.assert_called_once_with('10.0.0.1', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
        self.mock_pdu_instance.disable_outlets.assert_called_once_with([0, 1])
        self.assert_log_contains("INFO:board:Action 'off' completed successfully")

    def test_power_on_multi_socket_different_pdu_success(self):
        """Test successful 'on' action for multiple sockets on different PDUs."""
        self.simulate_args(['sockB', 'sockC', 'on'])
        self.configure_mocks()
        exit_code = self.run_script(['sockB', 'sockC', 'on'])
        self.assertEqual(exit_code, 0)
        self.mock_keyring_get_credential.assert_has_calls([call('pdu1', None), call('pdu2', None)], any_order=True)
        self.MockIPUClass.assert_has_calls([
            call('10.0.0.1', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD),
            call('10.0.0.2', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
        ], any_order=True)
        self.mock_pdu_instance.enable_outlets.assert_has_calls([call([1]), call([4])], any_order=True)
        self.assert_log_contains("INFO:board:Action 'on' completed successfully")

    def test_power_pdu_connection_error_continues(self):
        """Test script continues with other PDUs if one fails to connect."""
        self.simulate_args(['sockA', 'sockC', 'on'])
        self.configure_mocks(ipu_effect=[ConnectionRefusedError("Refused"), self.mock_pdu_instance])
        exit_code = self.run_script(['sockA', 'sockC', 'on'])
        self.assertEqual(exit_code, 1)
        self.MockIPUClass.assert_has_calls([
             call('10.0.0.1', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD),
             call('10.0.0.2', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
        ], any_order=True)
        self.mock_pdu_instance.enable_outlets.assert_called_once_with([4])
        self.assert_log_contains("ERROR:board:Connection refused to PDU 'pdu1'")
        self.assert_log_contains("INFO:board:Successfully executed 'on' for outlets [5] on PDU 'pdu2'")
        self.assert_log_contains("WARNING:board:Action could not be completed for some sockets due to PDU errors: sockA")

    def test_power_pdu_auth_error(self):
         """Test script handles authentication error for a PDU."""
         self.simulate_args(['sockA', 'on'])
         self.configure_mocks(ipu_effect=Exception("auth fail"))
         exit_code = self.run_script(['sockA', 'on'])
         self.assertEqual(exit_code, 1)
         self.MockIPUClass.assert_called_once_with('10.0.0.1', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
         self.assert_log_contains(f"ERROR:board:Authentication failed for PDU 'pdu1' (10.0.0.1) using credentials from keyring for user '{DEFAULT_MOCK_USERNAME}'.")
         self.assert_log_contains("WARNING:board:Action could not be completed for some sockets due to PDU errors: sockA")

    # --- PDU Action Error Tests ---
    def test_power_action_enable_exception(self):
        """Test handling of exception during enable_outlets call."""
        self.simulate_args(['sockA', 'on'])
        self.configure_mocks(enable_outlets_effect=Exception("Enable failed"))
        exit_code = self.run_script(['sockA', 'on'])
        self.assertEqual(exit_code, 1)
        self.MockIPUClass.assert_called_once_with('10.0.0.1', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
        self.mock_pdu_instance.enable_outlets.assert_called_once_with([0])
        self.assert_log_contains("ERROR:board:PDU communication error with 'pdu1' (10.0.0.1): Enable failed. Skipping PDU.")
        self.assert_log_contains("WARNING:board:Action could not be completed for some sockets due to PDU errors: sockA")

    def test_power_action_disable_exception(self):
        """Test handling of exception during disable_outlets call."""
        self.simulate_args(['sockC', 'off'])
        self.configure_mocks(disable_outlets_effect=TimeoutError("Disable timeout"))
        exit_code = self.run_script(['sockC', 'off'])
        self.assertEqual(exit_code, 1)
        self.MockIPUClass.assert_called_once_with('10.0.0.2', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
        self.mock_pdu_instance.disable_outlets.assert_called_once_with([4])
        self.assert_log_contains("ERROR:board:Connection timed out to PDU 'pdu2' (10.0.0.2). Check PDU status. Skipping PDU.")
        self.assert_log_contains("WARNING:board:Action could not be completed for some sockets due to PDU errors: sockC")

    # --- Logging Verbosity Test ---
    def test_verbose_logging(self):
        """Test that -v enables DEBUG logging."""
        self.simulate_args(['-v', 'sockA', 'on'])
        self.configure_mocks()
        exit_code = self.run_script(['-v', 'sockA', 'on'])
        self.assertEqual(exit_code, 0)
        # Check for a different, reliable DEBUG message
        self.assert_log_contains("DEBUG:board:Verbose logging enabled.")
        self.assert_log_contains("DEBUG:board:Connecting to PDU 'pdu1'")

    # --- Argument Edge Case ---
    def test_action_duplicate_sockets(self):
        """Test providing duplicate socket names."""
        self.simulate_args(['sockA', 'sockB', 'sockA', 'off'])
        self.configure_mocks()
        exit_code = self.run_script(['sockA', 'sockB', 'sockA', 'off'])
        self.assertEqual(exit_code, 0)
        self.MockIPUClass.assert_called_once_with('10.0.0.1', DEFAULT_MOCK_USERNAME, DEFAULT_MOCK_PASSWORD)
        self.mock_pdu_instance.disable_outlets.assert_called_once_with([0, 1])
        # Check log message includes IP and uses unique names
        self.assert_log_contains("INFO:board:Processing action 'off' for PDU 'pdu1' (10.0.0.1) affecting sockets: sockA, sockB")
        self.assert_log_contains("INFO:board:Action 'off' completed successfully")


# --- Main execution for running tests ---
if __name__ == '__main__':
    unittest.main(argv=['first-arg-is-ignored'], exit=False, verbosity=2)