# -*- coding: utf-8 -*-
"""PDU Control Script

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1l6PCb6qMYRayjIQggNnUt6Ih_lTrw3cA
"""

#!/usr/bin/env python3
# pylint: disable=invalid-name, too-many-arguments # Allow lowercase module-level variables, function args > 5

"""
Script to control Intellinet 163682 PDU sockets and associated serial consoles.

Reads configuration from a JSON file (default: pdu_config.json), retrieves
PDU credentials securely from the system keyring, and accepts commands via
command-line arguments using argparse. Supports acting on multiple sockets
for 'on'/'off' actions. Uses standard logging.
"""

import sys
import subprocess
import os
import json
import argparse # Standard library imports first
import logging
from collections import defaultdict
import keyring # Third-party imports after standard

# --- Constants ---
DEFAULT_CONFIG_FILENAME = "pdu_config.json"

# --- Logging Setup ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
log = logging.getLogger(__name__) # Use a named logger

# --- Dependency Import & Check ---
try:
    from intellinet_pdu_api.api import IPU
# E0701: Put ModuleNotFoundError before its parent ImportError
except ModuleNotFoundError:
    log.exception("Fatal: Module 'intellinet_pdu_api' not found.")
    print("Ensure the library folder is named correctly ('intellinet_pdu_api') and "
          "is in the same directory as the script or in the Python path.", file=sys.stderr)
    sys.exit(1)
except ImportError as e:
    log.exception("Fatal: Failed importing dependencies for intellinet_pdu_api.api: %s", e)
    print("Ensure the 'intellinet_pdu_api' library folder is correctly placed and "
          "all dependencies (like 'lxml') are installed (`pip install lxml`).",
          file=sys.stderr)
    sys.exit(1)

# --- Helper Functions ---

def fatal_error(message, exit_code=1):
    """Logs a critical error and exits."""
    log.critical(message)
    sys.exit(exit_code)

def load_config(filename):
    """Loads configuration from the specified JSON file."""
    log.debug("Attempting to load config from '%s'", filename)
    if not os.path.exists(filename):
        fatal_error(f"Configuration file '{filename}' not found.", exit_code=3)
    try:
        with open(filename, 'r', encoding='utf-8') as f:
            config = json.load(f)
        log.info("Successfully loaded configuration from '%s'", filename)
        return config
    except json.JSONDecodeError as e: # pylint: disable=redefined-outer-name
        fatal_error(f"Error decoding JSON from '{filename}': {e}", exit_code=3)
    except OSError as e: # pylint: disable=redefined-outer-name
        fatal_error(f"Error reading configuration file '{filename}': {e}", exit_code=3)
    # W0718: Catching general Exception is okay here to report unexpected file errors
    except Exception as e: # pylint: disable=broad-exception-caught, redefined-outer-name
        log.exception("Unexpected error loading config file '%s'", filename)
        fatal_error(f"Unexpected error reading configuration file '{filename}': {e}", exit_code=3)
    return None # Should not be reached

# --- Configuration Validation Functions ---

def _validate_pdus_section(pdus_data):
    """Validates the 'pdus' section of the config."""
    errors = []
    if not isinstance(pdus_data, dict):
        errors.append("Config 'pdus' section must be an object (dictionary).")
        return errors

    for pdu_id, pdu_info in pdus_data.items():
        if not isinstance(pdu_info, dict):
            errors.append(f"PDU entry '{pdu_id}' must be an object.")
            continue
        if 'ip' not in pdu_info:
            errors.append(f"PDU '{pdu_id}' is missing required key 'ip'.")
        elif not isinstance(pdu_info['ip'], str) or not pdu_info['ip']:
            errors.append(f"PDU '{pdu_id}' key 'ip' must be a non-empty string.")
        elif isinstance(pdu_info['ip'], str):
            parts = pdu_info['ip'].split('.')
            if len(parts) != 4 or not all(
                p.isdigit() and 0 <= int(p) <= 255 for p in parts
            ):
                errors.append(f"PDU '{pdu_id}' has an invalid 'ip' format: {pdu_info['ip']}.")
        if 'username' in pdu_info or 'password' in pdu_info:
            log.warning("PDU '%s' contains 'username' or 'password'. "
                       "These should be removed and stored in the system keyring.", pdu_id)
    return errors

def _validate_sockets_section(sockets_data, pdu_ids):
    """Validates the 'sockets' section of the config."""
    errors = []
    if not isinstance(sockets_data, dict):
        errors.append("Config 'sockets' section must be an object (dictionary).")
        return errors

    for socket_name, socket_info in sockets_data.items():
        if not isinstance(socket_info, dict):
            errors.append(f"Socket entry '{socket_name}' must be an object.")
            continue
        # Check required keys
        for key in ['pdu_id', 'outlet', 'serial', 'baudrate']:
            if key not in socket_info:
                errors.append(f"Socket '{socket_name}' is missing required key '{key}'.")
        # Validate pdu_id reference
        pdu_id = socket_info.get('pdu_id')
        if pdu_id and pdu_id not in pdu_ids:
            errors.append(f"Socket '{socket_name}' references unknown pdu_id '{pdu_id}'.")
        # Validate outlet number
        outlet = socket_info.get('outlet')
        if not isinstance(outlet, int) or outlet <= 0:
            errors.append(
                f"Socket '{socket_name}' key 'outlet' must be a positive integer."
            )
        # Validate serial port
        serial = socket_info.get('serial')
        if not isinstance(serial, str) or not serial.startswith('/'):
            errors.append(
                f"Socket '{socket_name}' key 'serial' must be a string starting with '/'."
            )
        # Validate baudrate
        baudrate = socket_info.get('baudrate')
        if not isinstance(baudrate, int) or baudrate <= 0:
            errors.append(
                f"Socket '{socket_name}' key 'baudrate' must be a positive integer."
            )
    return errors

def _check_conflicts(sockets_data):
    """Checks for conflicting outlet or serial port assignments."""
    errors = []
    socket_outlets = {}
    socket_serials = {}
    for socket_name, socket_info in sockets_data.items():
        if not isinstance(socket_info, dict):
            continue
        pdu_id = socket_info.get('pdu_id')
        outlet = socket_info.get('outlet')
        serial = socket_info.get('serial')
        # Check outlet conflict
        if pdu_id and isinstance(outlet, int) and outlet > 0:
            outlet_key = (pdu_id, outlet)
            if outlet_key in socket_outlets:
                errors.append(
                    f"Conflict: Socket '{socket_name}' and '{socket_outlets[outlet_key]}' "
                    f"both use PDU '{pdu_id}' outlet {outlet}."
                )
            else:
                socket_outlets[outlet_key] = socket_name
        # Check serial conflict
        if serial and isinstance(serial, str):
            if serial in socket_serials:
                errors.append(
                    f"Conflict: Socket '{socket_name}' and '{socket_serials[serial]}' "
                    f"both use serial port '{serial}'."
                )
            else:
                socket_serials[serial] = socket_name
    return errors


def validate_config(config, filename):
    """Validates the overall config structure by calling helper functions."""
    log.debug("Validating configuration structure...")
    if not isinstance(config, dict):
        fatal_error(f"Configuration file '{filename}' validation error: "
                    "Config root must be a JSON object (dictionary).", exit_code=4)

    all_errors = []
    pdus_data = config.get('pdus', {})
    sockets_data = config.get('sockets', {})

    all_errors.extend(_validate_pdus_section(pdus_data))
    all_errors.extend(_validate_sockets_section(sockets_data, pdus_data.keys()))
    if isinstance(sockets_data, dict):
        all_errors.extend(_check_conflicts(sockets_data))

    if all_errors:
        error_message = f"Configuration file '{filename}' has validation errors:\n"
        error_message += "\n".join([f"- {e}" for e in all_errors])
        fatal_error(error_message, exit_code=4)

    log.info("Configuration validation passed.")


# --- Action Functions ---

def run_console_action(socket_info):
    """Handles the 'console' action for a single socket."""
    serial_port = socket_info['serial']
    baud_rate = socket_info['baudrate']
    socket_name = socket_info['_name']

    log.info("Executing 'console' action for socket '%s' (%s @ %d baud)",
             socket_name, serial_port, baud_rate)
    picocom_cmd = ["picocom", "-b", str(baud_rate), serial_port]
    try:
        subprocess.check_output(["which", "picocom"], stderr=subprocess.DEVNULL)
    except (FileNotFoundError, subprocess.CalledProcessError):
        log.error("'picocom' command not found or not executable.")
        return False

    try:
        log.info("Attempting to start console via picocom...")
        print(f" -> Starting picocom on {serial_port} @ {baud_rate} baud.",
              file=sys.stderr)
        print(" -> Use Ctrl+A, Ctrl+X to exit picocom.", file=sys.stderr)
        # R1732: Ignore - Cannot use 'with' as process needs to detach
        process = subprocess.Popen(picocom_cmd, start_new_session=True) # pylint: disable=consider-using-with
        log.info("Successfully launched picocom (PID: %s) for socket '%s'",
                 process.pid, socket_name)
        sys.exit(0)
    # W0718: Catching general Exception justified for unexpected Popen errors
    except Exception as e: # pylint: disable=broad-exception-caught, redefined-outer-name
        log.exception("Failed to start console process for socket '%s' on %s: %s",
                      socket_name, serial_port, e)
        return False
    return False


# R0914, R0912, R0915: Complexity warnings ignored for this function
# pylint: disable=too-many-locals, too-many-branches, too-many-statements
def run_power_actions(sockets_to_control, action, config):
    """Handles 'on'/'off' actions, grouping by PDU."""
    pdus_to_control = defaultdict(list)

    for socket_name in sockets_to_control:
        if socket_name not in config.get('sockets', {}):
            log.warning("Socket '%s' not found in config. Skipping.", socket_name)
            continue
        socket_info = config['sockets'][socket_name]
        pdu_id = socket_info['pdu_id']
        socket_info['_name'] = socket_name
        pdus_to_control[pdu_id].append(socket_info)

    overall_success = True
    processed_sockets = set()

    for pdu_id, socket_list in pdus_to_control.items():
        if pdu_id not in config.get('pdus', {}):
            log.error("PDU ID '%s' referenced by sockets not found in "
                      "config 'pdus' section. Skipping PDU.", pdu_id)
            overall_success = False
            continue
        pdu_ip = config['pdus'][pdu_id]['ip']

        unique_socket_names_on_pdu = sorted(list({s['_name'] for s in socket_list}))
        log.info("Processing action '%s' for PDU '%s' (%s) affecting sockets: %s",
                 action, pdu_id, pdu_ip, ", ".join(unique_socket_names_on_pdu))

        pdu_username = None
        pdu_password = None
        try:
            credential = keyring.get_credential(pdu_id, None)
            if credential:
                pdu_username = credential.username
                pdu_password = credential.password
            if not pdu_username or not pdu_password:
                log.error("Credentials not found or incomplete for PDU '%s' in keyring. "
                          "Store them first (e.g., 'keyring set %s <user>'). Skipping PDU.",
                          pdu_id, pdu_id)
                overall_success = False
                continue
        # W0718: Catching general Exception justified for unexpected keyring backend errors
        except Exception as e: # pylint: disable=broad-exception-caught, redefined-outer-name
            log.exception("Failed to retrieve credentials for PDU '%s' from keyring: %s. "
                          "Skipping PDU.", pdu_id, e)
            overall_success = False
            continue

        pdu_instance = None
        try:
            log.debug("Connecting to PDU '%s' (%s) as user '%s'",
                      pdu_id, pdu_ip, pdu_username)
            pdu_instance = IPU(pdu_ip, pdu_username, pdu_password)

            outlets = [
                s['outlet'] - 1 for s in socket_list
                if isinstance(s.get('outlet'), int)
            ]
            unique_outlets = set(outlets)
            outlets_0_based = sorted(list(unique_outlets))

            if not outlets_0_based:
                log.warning("No valid outlets found for PDU '%s' in the specified socket list. "
                          "Skipping.", pdu_id)
                continue

            log.debug("Targeting unique outlets (0-based): %s", outlets_0_based)

            if action == "on":
                pdu_instance.enable_outlets(outlets_0_based)
                log.info("Successfully executed 'on' for outlets %s on PDU '%s'",
                         [o+1 for o in outlets_0_based], pdu_id)
            elif action == "off":
                pdu_instance.disable_outlets(outlets_0_based)
                log.info("Successfully executed 'off' for outlets %s on PDU '%s'",
                         [o+1 for o in outlets_0_based], pdu_id)

            for s_info in socket_list:
                processed_sockets.add(s_info['_name'])

        except TypeError as e:
            log.error("Initialization error for PDU '%s' (%s): %s. "
                      "This might indicate an issue within the PDU library. Skipping PDU.",
                      pdu_id, pdu_ip, e)
            overall_success = False
        except ConnectionRefusedError:
            log.error("Connection refused to PDU '%s' (%s). Check IP/network. Skipping PDU.",
                      pdu_id, pdu_ip)
            overall_success = False
        except TimeoutError:
            log.error("Connection timed out to PDU '%s' (%s). Check PDU status. Skipping PDU.",
                      pdu_id, pdu_ip)
            overall_success = False
        # W0718: Catching general Exception justified for unexpected library/network errors
        except Exception as e: # pylint: disable=broad-exception-caught
            error_message = str(e)
            auth_indicators = ["authentication failed", "login incorrect",
                               "auth fail", "unauthorized"]
            if any(indicator in error_message.lower() for indicator in auth_indicators):
                log.error("Authentication failed for PDU '%s' (%s) using credentials "
                          "from keyring for user '%s'. Verify stored credentials. "
                          "Skipping PDU. (Original error: %s)",
                          pdu_id, pdu_ip, pdu_username, e)
            else:
                log.exception("PDU communication error with '%s' (%s): %s. Skipping PDU.",
                              pdu_id, pdu_ip, e)
            overall_success = False
        finally:
            pass

    requested_socket_set = set(sockets_to_control)
    skipped_sockets = requested_socket_set - processed_sockets
    if skipped_sockets:
        log.warning("Action could not be completed for some sockets due to PDU errors: %s",
                    ", ".join(sorted(list(skipped_sockets))))
        overall_success = False

    return overall_success


# --- Main Execution ---

def main():
    """Main function to parse arguments and dispatch actions."""
    parser = argparse.ArgumentParser(
        description="Control PDU sockets and serial consoles.",
        epilog=f"Reads configuration from {DEFAULT_CONFIG_FILENAME} unless -c is specified. "
               "PDU credentials must be stored in the system keyring "
               "(service_name=pdu_id)."
    )
    parser.add_argument(
        '-c', '--config',
        default=DEFAULT_CONFIG_FILENAME,
        help=f"Path to the JSON configuration file (default: {DEFAULT_CONFIG_FILENAME})"
    )
    parser.add_argument(
        'socket_names',
        metavar='SOCKET_NAME',
        nargs='+',
        help="Name(s) of the socket(s) defined in the config file."
    )
    parser.add_argument(
        'action',
        choices=['on', 'off', 'console'],
        help="Action to perform: 'on', 'off', or 'console'."
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help="Enable verbose (DEBUG level) logging."
    )

    args = parser.parse_args()

    if args.verbose:
        log.setLevel(logging.DEBUG)
        log.debug("Verbose logging enabled.")

    log.debug("Parsed arguments: %s", args)

    config = load_config(args.config)
    validate_config(config, args.config)

    available_sockets_set = set(config.get('sockets', {}).keys())
    unknown_sockets = [name for name in args.socket_names if name not in available_sockets_set]
    if unknown_sockets:
        fatal_error(f"Unknown socket name(s): {', '.join(unknown_sockets)}. "
                    f"Available sockets: {', '.join(sorted(list(available_sockets_set)))}",
                    exit_code=1)

    if args.action == "console":
        if len(args.socket_names) > 1:
            fatal_error("The 'console' action can only be performed on a single socket.",
                        exit_code=1)
        socket_info = config['sockets'][args.socket_names[0]]
        socket_info['_name'] = args.socket_names[0]
        if not run_console_action(socket_info):
            sys.exit(1)

    elif args.action in ["on", "off"]:
        if not run_power_actions(args.socket_names, args.action, config):
            sys.exit(1)
        else:
            log.info("Action '%s' completed successfully for all specified sockets.", args.action)
            sys.exit(0)

    else:
        fatal_error(f"Internal error: Unhandled action '{args.action}'", exit_code=99)


if __name__ == "__main__":
    main()